# Docker

## Сети -------------------------------------------------

**docker network ls** - _выводит список сетей_

**docker network rm 568744125** - _выводит список сетей_

**docker network create rs-network** - _создать сеть_

## Образ -------------------------------------------------

Версии:

node:18
node:latest
node:alpine

### Команды:

docker images - выводит список доступных образов на docker хосте

docker pull <имя_образа> - скачивает из docker hub указанный образ. После имени образа можно через двоеточие указать версию образа или alpain. Если ничего не указать, то будет скачена latest версия.

docker image rm <имя_образа> - удаляет образ

docker image prune - удаляет все имеющиеся контейнеры

## Контейнер -------------------------------------------------

Команды:

docker ps -a - выводит список всех контейнеров, даже те которые не запущены. Без ключа (-a) будут выведены только запущенные контейнеры

docker rm <имя_контейнера> - удаление контейнера по имени

docker start/stop/restart <имя_контейнера> - стартует/останавливает/перезапускает докер контейнер

docker container prune - удаляет все докер контейнеры которые были остановлены

docker container inspect <имя_контейнера> - выводит всю информацию о докер контейнере. Например можно с помощью grep отфильтровать ip адрес

docker kill <имя_контейнера> - принудительно останавливает контейнер

Внутри докер контейнера можно запустить дополнительный процесс. Осуществляется это с помощью команды exec. Синтаксис:

docker exec <ключи> <имя*контейнера> <название*процесса> - важно соблюдать порядок. Вот как к примеру можно запустить в контейнере терминал и тут же к нему подключиться:

docker exec -it -u root 80b9ab4d8b22 sh

эта команда запустит в контейнере с id 80b9ab4d8b22 оболочку shell ( sh - терминал). -u root - говорит о том, что терминал будет запущен от имени пользователя root (u - user) и процесс будет запущен в it режиме (i - interactive, t - terminal)

docker logs <имя_контейнера> - позволяет вывести логи запущенного докера

docker attach <имя_контейнера> - позволяет подключиться к консоли запущенного докера, т.е. мы будем просматривать логи в режиме реального времени

Если подключиться к контейнеру и запустить там терминал, то с помощью hostname -i можно будет получить внутренний адрес докер контейнера

### Запуск контейнера:

docker run <имя_образа>

## Ключи:

-it (иногда -i -t) - -i - interactive, t - terminal. Есть сокращенная версия команды -it - обычно используется при запуске linux образов, что бы при запуске тут же подключиться к терминалу внутри докер контейнера. Для того что бы выйти из интерактивного режима необходимо ввести в консоль команду .exit

-d - detouch режим, говорит о том, что контейнер будет запущен в фоне

-p 8080:80 - публикация портов. Первым указывается внешний порт docker хоста, второй порт (80), это порт по которому будет доступен процесс внутри докера. Например мы запускаем в докере React приложение, которое внутри докера будет крутиться на 3000 порту, а снаружи на компьютере мы его слушать будем на 4000 порту. Таким образом настройка мапинга портов будет выглядеть так -p 4000:3000

--rm - этот ключ говорит о том, что контейнер будет удален сразу после остановки контейнера

--name - позволяет задать имя создаваемому контейнеру

-e MY_VAR=123 - позволяет при запуске контейнера задать переменные окружения. Здесь мы для примера создали переменную MY_VAR с значением 123

-v - volume, их же называют томами. Позволяют монтировать папку с docker хоста в папку внутри докера. Синтаксис: -v <путь к локальной папке>:<путь к папке внутри докера>. В качестве пути к локальной папке можно использовать глобальную переменную ${PWD} PWD - вернет путь к текущей директории

пример запуска докер контейнера nginx с применением всех ключей:

docker run -p 3000:80 -d --name my_nginx -e MY_VAR=123 -v /home/nardo/nginx:/usr/share/nginx/html --rm nginx

## helper

docker ps

http://localhost:3000/

docker exec -it my_nginx sh

docker stop my_nginx

docker ps -a

---

## Dockerfile
